# Product-Management
Welcome to the GitHub repository of our **Product Management System!** In this file, we would be keeping a record of the commits made to the project and a brief description of each and every commit with respect to the project. The project is mainly built using the **MERN Stack**, in which Node.js is used for server side code, MongoDB Atlas is mainly used for the database needs, Express.js is used for communicating with the server by means of requests and responses, and React.js is used for the Frontend and UI needs. 

### 18 Feb 2024 - Commit 1: The Backend code (Server-side code, Database logic and API routes):
In the server-side code, we import two important modules, `express` and `mongoose`. The express module is used for the **middleware** code (the code that is executed after the client sends a request and before the server sends a response). The `express.json()` method is used to retrieve the body of the request being sent to the server. The mongoose module is used to connect to the database and prepare a **schema** (the structure in which documents are added to the database). The routes consist of `GET` requests (to display all products or a single product), `POST` requests (to add a product to the database), `DELETE` request (to delete a product from a database) and `PATCH` request (to update a product). The logic for the CRUD operations is defined in the `productController.js` file.

### 26 Feb 2024 - Commit 2: Making a React app and Fetching Data:
A React app was created using `npx create-react-app` command. React.js allows us to divide the project into pages and components and is largely used for the Frontend part. In this commit, the **Home** component (Home.js) was made which displays all the products in the database using the `fetch()` function. A reusable component **ProductDetails.js** was also created which would be rendered in Home.js. This component receives the product as a prop and displays its properties. The name, description and cost of the product were fetched from the backend and were rendered onto the app. 

### 27 Feb 2024 - Commit 3: Creating a Product form to add new product:
In this commit, I have created a form which would ask the details of the product. On submitting the form, the product would be added to the database. The form contains input fields for the name, description, cost and the image of the product. On submitting the form, the data is converted into json by `JSON.stringify()` method, and a `POST` request is sent to the server along with the data received from the user. The updated data is then fetched again using the `fetch()` function. If an error occurs, then the error is displayed. If there are no errors in the request or response, then the data is stored successfully, and the input fields are cleared using the `useState` hook. 

### 29 Feb 2024 - Commit 4: Adding Context to data:
When a new product is added to the database from the form created earlier, the new product is not fetched and displayed along with the other products until the user refreshes the page. This problem is solved by the concept of **context**. Context is a global scope that is assigned to a specific component, so that any external component can change the state of that component. In this case, a context is assigned to the list of products such that whenever the product is added, the list of products is updated without having to refresh the page. This is done using `ProdContext.js` and the custom hook `useProdContext.js`. Note that we are enclosing the App component (the root component) in the Context Provider to use context in our applicaton.

### 2 Mar 2024 - Commit 5: Deleting products and Handling Error messages:
In this commit, we are handling `DELETE` requests from the frontend. I have added another case to the `ProdContext.js` file in which the `filter()` function is used which would filter out the product which is to be deleted. Therefore, we can implement the deleting operation from the frontend using context. In case the user does not fill out all the fields while adding a product, an error message would be displayed below the form, and the required fields would be highlighted. I have also used **TailWind CSS** to change the entire look of the project and make it more enhanced and flexible.

### 6 Mar 2024 - Commit 6: Fetching the details of a single product:
In case the user wants to have a look at the details of the product that has been added to the database, I have provided a button (a `<Link>` tag, to be more specific) called **View Details** below each product in the home page. On clicking this button, the user would be directed to a Details page `ProductInfo.js`. In this page, we fetch the details of a single product (the product that is selected by the user) using Fetch API. Hence, the name, description, cost and the image uploaded would be visible to the user on this page.

### 22 Mar 2024 - Commit 7: Authentication Introduction and Hashing Passwords:
In this commit, I have added a new schema (userModel.js), a new controller file which implements the schema (userController.js) and a new file for the login routes (users.js) for the authentication or the login functionality, which would allow different product databases for different users, and would add an extra layer of security to the website. Two `POST` requests were defined for the login and signup routes respectively. The user schema contains a statics signup function. The main task of this function is to check whether the email already exists, if the email does not exist, a document would be created with the email and the hashed password. The hashing of the password is done using the **bcrypt** module. The `genSalt()` function in this module to add generic characters to the password, and the `hash()` function is used to hash the password and the salt together.

### 26 Mar 2024 - Commit 8: Password Validation and Creation of Signup Tokens:
When a user tries to login or signup, we need to verify if the email and password entered are valid, and so we validate these fields with the functions `isEmail()` and `isStrongPassword()`. These functions are a part of the validator module. I have also created a signup token in this commit. When the client sends a authentication request to the server, it sends a JSON web token in return. This token is then verified by the frontend and the user is logged in or signed up. A token consists of three parts: a **header** (which contains the metadata and algorithms), a **payload** (which contains the non-sensitive data) and a **verify signature** (which is used to verify authenticity of the token). The tokens are also used for security purposes, as the functionalities will only be available to the authorized users.